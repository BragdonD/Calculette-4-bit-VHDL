-- Copyright (C) 2018  Intel Corporation. All rights reserved.
-- Your use of Intel Corporation's design tools, logic functions 
-- and other software and tools, and its AMPP partner logic 
-- functions, and any output files from any of the foregoing 
-- (including device programming or simulation files), and any 
-- associated documentation or information are expressly subject 
-- to the terms and conditions of the Intel Program License 
-- Subscription Agreement, the Intel Quartus Prime License Agreement,
-- the Intel FPGA IP License Agreement, or other applicable license
-- agreement, including, without limitation, that your use is for
-- the sole purpose of programming logic devices manufactured by
-- Intel and sold by Intel or its authorized distributors.  Please
-- refer to the applicable agreement for further details.
--C1L0 is add_4bit:add0|add_1bit:f0|res~0
C1L0 = A1L0 $ (A1L0);


--new_B_input[1] is new_B_input[1]
new_B_input[1] = A1L6 $ (A1L0);


--C1L0 is add_4bit:add0|add_1bit:f0|new_restraint~0
C1L0 = (A1L0 & (A1L0 $ (A1L0)));


--C1L0 is add_4bit:add0|add_1bit:f0|new_restraint~1
C1L0 = (A1L0 & (A1L0 $ (!A1L0)));


--C1_res is add_4bit:add0|add_1bit:f1|res
C1_res = A1L1 $ (new_B_input[1] $ (((C1L0) # (C1L0))));


--C1L0 is add_4bit:add0|add_1bit:f1|new_restraint~0
C1L0 = (new_B_input[1] & ((C1L0) # ((C1L0) # (A1L1)))) # (!new_B_input[1] & (A1L1 & ((C1L0) # (C1L0))));


--C1L0 is add_4bit:add0|add_1bit:f2|res~0
C1L0 = A1L0 $ (A1L15 $ (A1L0 $ (C1L0)));


--C1L0 is add_4bit:add0|add_1bit:f2|new_restraint~0
C1L0 = (A1L15 & ((C1L0) # (A1L0 $ (A1L0)))) # (!A1L15 & (C1L0 & (A1L0 $ (A1L0))));


--C1L0 is add_4bit:add0|add_1bit:f3|res~0
C1L0 = A1L0 $ (A1L0 $ (A1L0 $ (C1L0)));


--C1L0 is add_4bit:add0|add_1bit:f3|new_restraint~0
C1L0 = (A1L0 & ((C1L0) # (A1L0 $ (A1L0)))) # (!A1L0 & (C1L0 & (A1L0 $ (A1L0))));


--A1L0 is output[0]~output
A1L0 = OUTPUT_BUFFER.O(.I(C1L0), , , , , , , , , , , , , , , , , );


--output[0] is output[0]
output[0] = OUTPUT();


--A1L0 is output[1]~output
A1L0 = OUTPUT_BUFFER.O(.I(C1_res), , , , , , , , , , , , , , , , , );


--output[1] is output[1]
output[1] = OUTPUT();


--A1L0 is output[2]~output
A1L0 = OUTPUT_BUFFER.O(.I(C1L0), , , , , , , , , , , , , , , , , );


--output[2] is output[2]
output[2] = OUTPUT();


--A1L0 is output[3]~output
A1L0 = OUTPUT_BUFFER.O(.I(C1L0), , , , , , , , , , , , , , , , , );


--output[3] is output[3]
output[3] = OUTPUT();


--A1L0 is out_signs~output
A1L0 = OUTPUT_BUFFER.O(.I(!C1L0), , , , , , , , , , , , , , , , , );


--out_signs is out_signs
out_signs = OUTPUT();


--A1L0 is in_A[0]~input
A1L0 = INPUT_BUFFER(.I(in_A[0]), , );


--in_A[0] is in_A[0]
in_A[0] = INPUT();


--A1L0 is in_B[0]~input
A1L0 = INPUT_BUFFER(.I(in_B[0]), , );


--in_B[0] is in_B[0]
in_B[0] = INPUT();


--A1L1 is in_A[1]~input
A1L1 = INPUT_BUFFER(.I(in_A[1]), , );


--in_A[1] is in_A[1]
in_A[1] = INPUT();


--A1L6 is in_B[1]~input
A1L6 = INPUT_BUFFER(.I(in_B[1]), , );


--in_B[1] is in_B[1]
in_B[1] = INPUT();


--A1L0 is operation~input
A1L0 = INPUT_BUFFER(.I(operation), , );


--operation is operation
operation = INPUT();


--A1L15 is in_A[2]~input
A1L15 = INPUT_BUFFER(.I(in_A[2]), , );


--in_A[2] is in_A[2]
in_A[2] = INPUT();


--A1L0 is in_B[2]~input
A1L0 = INPUT_BUFFER(.I(in_B[2]), , );


--in_B[2] is in_B[2]
in_B[2] = INPUT();


--A1L0 is in_A[3]~input
A1L0 = INPUT_BUFFER(.I(in_A[3]), , );


--in_A[3] is in_A[3]
in_A[3] = INPUT();


--A1L0 is in_B[3]~input
A1L0 = INPUT_BUFFER(.I(in_B[3]), , );


--in_B[3] is in_B[3]
in_B[3] = INPUT();


